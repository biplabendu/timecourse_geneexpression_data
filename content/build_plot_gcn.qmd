---
title: "Build gene co-expression network (GCN) from time-course gene expression data"
editor_options: 
  chunk_output_type: console
---

```{r}
dttm <- Sys.Date()
```

---

> Last updated on `r dttm`.

___

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(warning = F)
knitr::opts_chunk$set(message = F)

## For more inspiration on customizing the html output, refer to the following:
# https://bookdown.org/yihui/rmarkdown/html-document.html#table-of-contents

```


```{r lib_params}
library(dplyr)
library(dbplyr)
library(ggplot2)
for (i in list.files(here::here("R"), full.names = TRUE)) source(i)

# SAMPLE NAME
## specify sample name
sample.names <- c("dmel-head","mmus-brain_stem")
sample.cycles <- c("LD", "DD")

## SPECIFY THE DATASET TO BUILD GCN WITH
which.sample <- sample.names[1]
```


# Create databases

```{r load_data}
samples <- purrr::map(
  sample.names,
  function(x) {
    c(
      strsplit(x, "-")[[1]][1],
      strsplit(x, "-")[[1]][2]
    )
  }
)

paths <- list()
for (i in 1:length(samples)) {
 paths[[i]] <- glue::glue(
   "tissue_data/{samples[[i]][1]}/{samples[[i]][2]}/{samples[[i]][2]}.txt"
 ) 
}

data.db <- list()
for (i in 1:length(paths)) {
  data.db[[i]] <- read.csv(
      here::here(paths[[i]]),
      sep = "\t",
      header = TRUE,
      na.strings = c("", " ", "na", "NA", "Na")
    ) |> 
    as_tibble() |> 
    rename(
      gene_name = ID
    )
}
# set names
data.db <- data.db |> setNames(sample.names)

# cat("Here are the tables, in each database.")
# purrr::map(
#   data.db,
#   ~ src_dbi(.x)
# )
```

# Load data

```{r}
writeLines(paste0("Selected Dataset: ", which.sample))

# extract the (gene-expr X time-point-of-sampling) data
dat <-
  data.db %>%
  purrr::pluck(which.sample) |> 
  # tbl(paste0(which.sample ,"_log2expression")) %>%
  mutate(
    across(
      !gene_name,
      ~ log2(.x + 1)
    )
  ) |> 
  select(gene_name, everything()) %>%
  collect()

writeLines(
"What is the dimensions of the original dataset? 
[Rows = #genes, Cols = #samples]"
)
dim(dat[-1])

```

# Filter data

```{r clean_data}
# Which genes are expressed throughout the day in forager heads?
  # count the number of time points that has ≥ 1 FPKM
  # subset the data and only keep the filtered genes

# arguments
min_expression = 1
min_timepoints = 8

dat <- dat |> 
  ## to do ----
  ## convert into function
  mutate(
    n_samples = rowSums(
      across(
        !gene_name,
        ~ .x >= min_expression
      ),
      na.rm = TRUE
    )
  ) |> 
  filter(
    n_samples >= min_timepoints
  ) |> 
  select(
    - n_samples
  ) |> 
  # TEMP FIX ----
  # Multiple rows per gene
  # fix: only taking the first row
  # might not be the best way
  group_by(gene_name) |> 
  slice(1)

writeLines("Dimensions of the data post-filtering step [Rows = #genes, Cols = #samples]")
dim(dat[-1])

```

This is our cleaned, input data file for building the circadian GCN. 


# Format data

- Log2 transform the data

```{r format_data, fig.height=6, fig.width=6}

datExpr = as.data.frame(t(dat[-c(1)]))
names(datExpr) = dat$gene_name
rownames(datExpr) = names(dat)[-c(1)]

# USE THE FOLLOWING CODE TO CHECK IF YOU HAVE ANY BAD SAMPLES #
  # gsg = goodSamplesGenes(datExpr, verbose = 3);
  # gsg$allOK

  # sampleTree = hclust(dist(datExpr0), method = "average");
  # # Plot the sample tree: Open a graphic output window of size 12 by 9 inches
  # # The user should change the dimensions if the window is too large or too small.
  # sizeGrWindow(12,9)
  # #pdf(file = "Plots/sampleClustering.pdf", width = 12, height = 9);
  # par(cex = 1);
  # par(mar = c(0,4,2,0))
  # plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5,
  #      cex.axis = 1.5, cex.main = 2)

# save the number of genes and samples
# that will be used to create the circadian GCN
nGenes = ncol(datExpr)
nSamples = nrow(datExpr)

writeLines("Visualizing the log-transformed data")

datExpr |> 
  tibble::rownames_to_column(
    "sample"
  ) |> 
  as_tibble() |> 
  tidyr::pivot_longer(
    cols = !sample,
    names_to = "gene_id",
    values_to = "log2_fpkm"
  ) |> 
  mutate(
    sample = stringr::str_remove(sample, "ZT")
  ) |> 
  ggplot(
    aes(
      x = log2_fpkm, 
      # color = sample,
      fill = sample
    )
  ) + 
  geom_density(
    position = "stack"
  ) + 
  theme_bw(25) +
  scale_fill_manual(
    values = viridis::viridis(nSamples)
  ) +
  theme(
    legend.position = "bottom",
    legend.justification = "right"
  ) +
  guides(
    fill = guide_legend(
      nrow = 3,
      byrow=TRUE
    )
  )

```


# Calculate gene-gene similarity

```{r gene_sim_matrix, fig.height=6, fig.width=6}
# Calculate Kendall's tau-b correlation for each gene-gene pair
sim_matrix <- calculate_gene_gene_sim(
  data = datExpr,
  name = which.sample,
  cache = FALSE
)


## Let's display a chunk of the matrix (code from Hughitt 2016; github)
heatmap_indices <- sample(nrow(sim_matrix), 200)

writeLines(paste0("Plotting a chunk of the gene-gene similarity matrix with ", length(heatmap_indices), " genes."))
gplots::heatmap.2(t(sim_matrix[heatmap_indices, heatmap_indices]),
          col=viridis::inferno(100),
          labRow=NA, labCol=NA,
          trace='none', dendrogram='row',
          xlab='Gene', ylab='Gene',
          main= paste0("Similarity matrix \nmethod = 'kendall' \n (", length(heatmap_indices), " random genes)"),
          density.info='none', revC=TRUE)

```


# Create adjacency matrix

## USER INPUT REQUIRED ----
To create the adjacency matrix, we need to first identify the soft-thresholding power (see WGCNA for more info).

```{r soft_thresholding_power, fig.height=6, fig.width=8}
writeLines("Performing network topology analysis to pick soft-thresholding power")
# Choose a set of soft-thresholding powers
powers = c(c(1:10), seq(from = 12, to=30, by=2))
# # Call the network topology analysis function
sft = WGCNA::pickSoftThreshold(datExpr, powerVector = powers, verbose = 5)

writeLines("Plotting the resutls from the network topology analysis")
plot_network_topology(
  data = sft,
  height = 0.90
)
```

> NOTE: The scale-free topology fit index reaches close to 1 (red horizontal line = 0.90) at a `soft-thresholding-power == 9`.

Now, we can go ahead and create our adjacency matrix by power-transforming the similarity matrix (see WGCNA for more info).



```{r adjacency_matrix, fig.height=6, fig.width=6}
## Specify the soft-thresholding-power
soft.power = 9

# Construct adjacency matrix
# TO DO: make function ----
adj_matrix <- WGCNA::adjacency.fromSimilarity(
  sim_matrix,
  power = soft.power,
  type = "signed"
)

## Delete similarity matrix to free up memory
rm(sim_matrix)
gc()
```


```{r}
# Convert adj_matrix to matrix
gene_ids <- rownames(adj_matrix)

adj_matrix <- matrix(adj_matrix, nrow=nrow(adj_matrix))
rownames(adj_matrix) <- gene_ids
colnames(adj_matrix) <- gene_ids

writeLines(paste0("Plotting the power-transformed adjacency matrix for the same ", length(heatmap_indices)," genes as above"))
## Same heatmap as before, but now with the power-transformed adjacency matrix
gplots::heatmap.2(t(adj_matrix[heatmap_indices, heatmap_indices]),
                  col=viridis::inferno(100),
                  labRow=NA, labCol=NA,
                  trace='none', dendrogram='row',
                  xlab='Gene', ylab='Gene',
                  main='Adjacency matrix\n(power transformed)',
                  density.info='none', revC=TRUE)

```

# Identify gene clusters

The following steps are performed as per guidelines from the WGCNA package and several tutorials made available online.

### 2.1 Create topological overalp matrix

```{r adj_to_TOM, fig.height=4, fig.width=8}
# Turn adjacency into topological overlap
TOM = WGCNA::TOMsimilarity(adj_matrix)
dissTOM = 1 - TOM

# Call the hierarchical clustering function
geneTree = hclust(as.dist(dissTOM), method = "average")

writeLines("Plotting the resulting clustering tree (dendrogram)")

plot(
  geneTree, 
  xlab="", 
  sub="", 
  main = "Gene clustering\non TOM-based dissimilarity (dissTOM)",
  labels = FALSE, 
  hang = 0.04
)

```

### 2.2 Identify clusters

User defined parameters:

- minimum size (number of genes) of modules | var-name: minModuleSize

```{r identify_clusters}
# We like large modules, 
# so we set the minimum module size relatively high:
minModuleSize = 50;

# Module identification using dynamic tree cut:
dynamicMods= dynamicTreeCut::cutreeDynamic(
  dendro = geneTree,
  distM = dissTOM,
  method = "hybrid",
  verbose = 4,
  deepSplit = 3, 
  # see WGCNA for more info on tuning parameters
  pamRespectsDendro = FALSE,
  minClusterSize = minModuleSize
);

# view number of genes in each module
# table(dynamicMods)

writeLines("How many genes are there in each of the initial modules (clusters) detected?")
# Convert numeric lables into colors
dynamicColors = WGCNA::labels2colors(dynamicMods)
table(dynamicColors)

```

### 2.3 Merge similar modules

User defined parameters:

- minimum correlation between two modules above which they are merged into one | var-name: MEDissThres


```{r refine_cluster, fig.height=4, fig.width=8}
# Calculate eigengenes
MEList = WGCNA::moduleEigengenes(datExpr, colors = dynamicColors)
MEs = MEList$eigengenes

# Calculate dissimilarity of module eigengenes
MEDiss = 1-cor(MEs, method = "kendall");

writeLines("Clustering the module eigengenes and identifying a cutoff to merge similar modules")
# Cluster module eigengenes
METree = hclust(as.dist(MEDiss), method = "average");
# Plot the result
plot(METree, main = "Clustering of module eigengenes",
     xlab = "", sub = "MEDiss = 1-cor(MEs, method = 'kendall')")
```


#### NEED USER INPUT ----

```{r}
# user-specified parameter value; see WGCNA manual for more info
# We choose a height cut of 0.25, 
# corresponding to correlation of 0.75 
# (merge modules that have corr ≥ 0.75)
MEDissThres = 0.25

# Plot the cut line into the dendrogram
plot(METree, main = "Clustering of module eigengenes",
     xlab = "", sub = "MEDiss = 1-cor(MEs, method = 'kendall')")
abline(h=MEDissThres, col = "red")

writeLines(
  paste0("Merging modules that have a correlation ≥ ", 1-MEDissThres)
)
# Call an automatic merging function
merge = WGCNA::mergeCloseModules(
  datExpr, 
  dynamicColors, 
  cutHeight = MEDissThres, 
  verbose = 3
)

# The merged module colors
mergedColors = merge$colors;
# Eigengenes of the new merged modules:
mergedMEs = merge$newMEs;

writeLines("Plotting the identified clusters (denoted with colors) before and after merging.")
# sizeGrWindow(12, 9)
WGCNA::plotDendroAndColors(geneTree,
                    cbind(dynamicColors, mergedColors),
                    c("Dynamic Tree Cut", "Merged dynamic"),
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05)

# Rename to moduleColors
moduleColors = mergedColors

# Construct numerical labels corresponding to the colors
colorOrder = c("grey", 
               WGCNA::standardColors(50));
moduleLabels = match(moduleColors, colorOrder)-1
```





### 2.4 Calculate module-module similarity

```{r module_sim_matrix, fig.height=6, fig.width=6}
writeLines("Calculating module-module similarity based on module-eigengene-expression.")
# Calculate similarity of the eigen-genes
sim_matrix_ME <- cor(mergedMEs, method = "kendall")

# calculate adj_matrix
adj_matrix_ME <- WGCNA::adjacency.fromSimilarity(
  sim_matrix_ME,
  power=1,        # DO NOT power transform
  type='signed'
)

## CHANGE THE NAMES OF THE MODULES;
module_ids <- data.frame(
  old_labels = rownames(adj_matrix_ME) %>% 
    stringr::str_split("ME", 2) %>% 
    sapply("[", 2) %>% 
    as.character(),
  new_labels = paste0(
    "C", 
    1:nrow(adj_matrix_ME)
  )
)
# and coerce into matrix
adj_matrix_ME <- matrix(
  adj_matrix_ME, 
  nrow = nrow(adj_matrix_ME)
)
rownames(adj_matrix_ME) <- module_ids$new_labels
colnames(adj_matrix_ME) <- module_ids$new_labels

# ## KEEP THE SAME MODULE NAMES (named by color)
# gene_ids <- rownames(adj_matrix_ME)
# # coerce into a matrix
# adj_matrix_ME <- matrix(adj_matrix_ME, nrow=nrow(adj_matrix_ME))
# rownames(adj_matrix_ME) <- gene_ids
# colnames(adj_matrix_ME) <- gene_ids

writeLines("Plotting the adjacency matrix that shows module-module similarity in expression")
gplots::heatmap.2(t(adj_matrix_ME),
                  col=viridis::inferno(100),
                  # labRow=NA, labCol=NA,
                  trace='none', dendrogram='row',
                  xlab='', ylab='',
                  # main='Similarity matrix - MEs \n correlation method = "kendall")',
                  main='Adjacency matrix - MEs \n (module-module similarity)',
                  density.info='none', revC=TRUE)


```

### 2.5 Visualize the network

```{r visualize_network, fig.height=8, fig.width=8}

adj_matrix_ME_igraph = adj_matrix_ME

# get rid of low correlations (0.6 & 0.8 are arbitrary) [0.7 and 0.9]
adj_matrix_ME_igraph[
  adj_matrix_ME_igraph < 0.4
] <- 0
adj_matrix_ME_igraph[
  adj_matrix_ME_igraph < 0.7 & adj_matrix_ME_igraph > 0
] <- 0.2
adj_matrix_ME_igraph[
  adj_matrix_ME_igraph >= 0.7
] <- 1

# build_network
network <- igraph::graph_from_adjacency_matrix(
  adj_matrix_ME_igraph,
  mode = "upper",
  weighted = T,
  diag = F
)

# # simplify network
# network <- igraph::simplify(network)  # removes self-loops

# # remove isolated vertices (keep only the nodes)
# isolated <- which(igraph::degree(network)==0)
# network <- igraph::delete_vertices(network, isolated)


# colors <- as.character(module_ids$old_labels)
# V(network)$color <- colors
igraph::V(network)$color <- "yellow"

# genes_ME <- factor(moduleColors, levels=colors) %>% summary()
igraph::V(network)$size <- igraph::degree(network, mode = "total")*25
# V(network)$size <- log2(genes_ME)^1.3

igraph::V(network)$label.color <- "black"
igraph::V(network)$frame.color <- "black"

igraph::E(network)$width <- igraph::E(network)$weight*5
igraph::E(network)$color <- "black"

# ## highlight shortest paths between two vetices
# short.path <- igraph::get.shortest.paths(network, "S_5", "S_15")
# E(network, path = unlist(short.path[[1]]))$color <- col.scheme[2]
# E(network, path = unlist(short.path[[1]]))$width <- E(network)$weight*8

writeLines("Visualizing a simplified representation of the circadian GCN")
par(mfrow = c(1,1))
plot(
  network,
  # size=100,
  # layout = igraph::layout.kamada.kawai,
  # layout = igraph::layout.fruchterman.reingold,
  # layout = igraph::layout.graphopt,
  layout = igraph::layout_in_circle,
  # vertex.label=NA
  # vertex.shape="none"
)
# dev.off()

```


# Save module identity

Obtain a list of genes in each module

```{r module_genes_list}
# Make a list that returns gene names for a given cluster
module_genes <- list()

modules.to.exclude <- c("")
# modules.to.exclude <- c(paste0("C",c(2,5,6,7,10:17,19)))
which.modules <- module_ids %>% 
  filter(!new_labels %in% modules.to.exclude) %>%
  pull(old_labels)
which.labels <- module_ids %>% 
  filter(!new_labels %in% modules.to.exclude) %>%
  pull(new_labels)

# Get the genes from each of the modules
for (i in 1:length(which.modules)) {
  # which color
  mod.color = as.character(which.modules[[i]])
  # subset
  module_genes[[i]] <- names(datExpr)[which(moduleColors==mod.color)]
  names(module_genes)[[i]] <- as.character(which.labels[[i]])
}

# # check the result | works
# names(module_genes)
# module_genes['C22']

# [13 Dec 2021]
# Save a csv with the module identity information for all genes used in building the GCN
# make a dataframe with gene_name and module_identity
for (i in 1:length(module_genes)){
  if (i == 1){
    dat_module_gene <- data.frame(
      gene_name = module_genes[[i]],
      module_identity = as.character(names(module_genes)[i])
    )
  }
  else{
   foo <- data.frame(
     gene_name = module_genes[[i]],
     module_identity = as.character(names(module_genes)[i])
   )
   dat_module_gene <- rbind(dat_module_gene, foo) 
  }
  
}

# TO DO:
# Save the `dat_module_gene` as a database table in the respective database.



```
