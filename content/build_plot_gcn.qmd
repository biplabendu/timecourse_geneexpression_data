---
title: "Build gene co-expression network (GCN) from time-course gene expression data"
editor_options: 
  chunk_output_type: console
---

```{r}
dttm <- Sys.Date()
```

---

> Last updated on `r dttm`.

___

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(warning = F)
knitr::opts_chunk$set(message = F)

## For more inspiration on customizing the html output, refer to the following:
# https://bookdown.org/yihui/rmarkdown/html-document.html#table-of-contents

```


```{r lib_params}
library(dplyr)
library(dbplyr)
library(ggplot2)
for (i in list.files(here::here("R"), full.names = TRUE)) {
  source(i)
}

# SAMPLE NAME
## specify sample name
sample.names <- c(
  # dmel
  "dmel-head",
  # mmus
  "mmus-brain_stem", 
  # panu
  "panu-hypothalamus"
)
# sample.cycles <- c("LD", "DD")

## SPECIFY THE DATASET TO BUILD GCN WITH
which.sample <- sample.names[2]

writeLines(
  glue::glue("Sample: {which.sample}")
)
```


# (INT) Create databases

```{r load_data}
data.db <- load_data(
  sample_names = sample.names
)

cat("Structure of input data:")
data.db[[which.sample]] |> 
  head(5) |> 
  mutate_if(
    is.numeric,
    ~ round(.x, 1)
  ) |> 
  DT::datatable(
    caption = "Column 1: Name of feature (gene), Columns 2-N: Timepoints, Value: Expression / Activity",
    rownames = FALSE
  )

# cat("Here are the tables, in each database.")
# purrr::map(
#   data.db,
#   ~ src_dbi(.x)
# )
```

# ONE-SHOT (make_modules)

```{r}
# data.db[[1]] |> 
#   glimpse() |> 
#   make_modules(
#     min_expression = 1,
#     min_timepoints = 4,
#   ) |> 
#   str(max.level = 1)
```

# STEP-BY-STEP

# (PREP) Log-transform data

```{r}
# Define the function
dat <- log2_transform_data(
  data = data.db[[which.sample]],
  id_column = "gene_name"
)
```

# (SUBSET) Filter data

```{r}
# Default: min_expression and min_timepoints
min_expression <- dat |> 
  select(-gene_name) |> 
  summarize(across(everything(), ~ mean(.x, na.rm = TRUE))) |> 
  rowMeans() |> 
  ceiling()

min_timepoints <- ceiling(ncol(dat)*(2/3))
```


```{r clean_data}
# Which genes are expressed throughout the day in forager heads?
  # count the number of time points that has ≥ 1 FPKM
  # subset the data and only keep the filtered genes
  
dat_sub <- dat |> 
  subset_data(
    min_expression = min_expression,
    min_timepoints = min_timepoints,
    id_column = "gene_name"
  )

writeLines("Dimensions of the data post-filtering step [Rows = #genes, Cols = #samples]")
dim(dat[-1])

```

# (SUMMARIZE) One series per gene

```{r}
dat_sub_unique <- dat_sub |>
  group_by(gene_name) |> 
  reframe(
    across(
      everything(),
      ~ mean(.x, na.rm = TRUE)
    )
  )
  
```


This is our cleaned, input data file for building the circadian GCN. 

# (WGCNA) Format data

- transpose the dataset: rows = timepoints, cols = genes

```{r format_data, fig.height=6, fig.width=6}
datExpr <- dat_sub_unique %>% 
  transpose_data() 
```

## QC

```{r}
datExpr %>%
  check_sample_quality()

datExpr %>% 
  plot_sample_expression()

```


# Calculate gene-gene similarity

```{r gene_sim_matrix, fig.height=6, fig.width=6}
# Calculate Kendall's tau-b correlation for each gene-gene pair
sim_matrix <- calculate_gene_gene_sim(
  data = datExpr,
  name = which.sample,
  cache = FALSE
)

```

## QC

```{r}
cat("Before power transformation:")
plot_sim_matrix(
  matrix = sim_matrix
)
```


# Create adjacency matrix

## USER INPUT REQUIRED ----
To create the adjacency matrix, we need to first identify the soft-thresholding power (see WGCNA for more info).

```{r soft_thresholding_power, fig.height=6, fig.width=8}
sft <- analyze_network_topology(
  data = datExpr
)
```


> NOTE: The scale-free topology fit index reaches close to 1 (red horizontal line) at a `soft-thresholding-power` of `r sft$powerEstimate`.


```{r}
my_estimate <- sft$fitIndices |> 
  filter(
    SFT.R.sq > 0.8 &
      SFT.R.sq <= 0.9,
    Power > 5 &
      Power < 14
  ) |> 
  arrange(
    Power
  ) |> 
  head(1) |> 
  pull(1)
```


Now, we can go ahead and create our adjacency matrix by power-transforming the similarity matrix (see WGCNA for more info).


```{r adjacency_matrix, fig.height=6, fig.width=6}
## Specify the soft-thresholding-power
soft.power = if_else(
  sft$powerEstimate < 16,
  max(sft$powerEstimate, my_estimate),
  my_estimate
)

cat("Selected soft-power:", soft.power)

# Construct adjacency matrix
# TO DO: make function ----
adj_matrix <- WGCNA::adjacency.fromSimilarity(
  sim_matrix,
  power = soft.power,
  type = "signed"
) |> 
  as.matrix()

cat("After power transformation:")
plot_sim_matrix(
  matrix = adj_matrix
)
```

# Identify gene clusters

The following steps are performed as per guidelines from the WGCNA package and several tutorials made available online.

### 2.1 Create topological overalp matrix

```{r adj_to_dissTOM, fig.height=4, fig.width=8}
# Turn adjacency into topological overlap
dissTOM = 1 - WGCNA::TOMsimilarity(adj_matrix)
# Call the hierarchical clustering function
geneTree = perform_hclust(
  data = dissTOM
)

```


### 2.2 Identify clusters

User defined parameters:

- minimum size (number of genes) of modules

> We like large modules, so we set the minimum module size relatively high (50).

```{r identify_clusters}
minModuleSize = 50
# Module identification using dynamic tree cut:
modules <- create_modules(
  tree = geneTree,
  dissTOM = dissTOM,
  data = datExpr,
  min_module_size = minModuleSize
)
```


### 2.3 Merge similar modules

User defined parameters:

- minimum correlation between two modules above which they are merged into one | var-name: MEDissThres

```{r merge_clusters}
cutoff <- 0.8

merge = create_modules(
  tree = geneTree,
  dissTOM = dissTOM,
  min_module_size = minModuleSize,
  merge_cutoff_similarity = 0.8, # 70 % similarity
  data = datExpr
)

n_modules <- ncol(merge$modules$newMEs)

while (n_modules > 15) {
  cutoff <- cutoff - 0.05
  merge <- create_modules(
    tree = geneTree,
    dissTOM = dissTOM,
    min_module_size = minModuleSize,
    merge_cutoff_similarity = cutoff, # 70 % similarity
    data = datExpr
  )
  n_modules <- ncol(merge$modules$newMEs)
}

cat("Cutoff:", cutoff)
cat("Number of modules:", n_modules)
```

### 2.4 Calculate module-module similarity

```{r module_sim_matrix, fig.height=6, fig.width=6}

adj_matrix_ME <- calculate_module_module_sim(
  merged_modules = merge[["modules"]]
)

```

### 2.5 Visualize the network

```{r visualize_network, fig.height=8, fig.width=8}
plot_adj_as_network(
  layout = igraph::layout_as_tree,
  matrix = adj_matrix_ME$ME,
  min_edge = 0.65,
  node_label_size = 1.2,
  node_size = 35,
  edge_size = 5,
  node_frame_col = "grey20",
  node_fill_col = "grey80",
  vertex.frame.width = 4
)
```


# Save module identity

Obtain a list of genes in each module

```{r module_genes_list}
module_genes <- tidy_modules(
  merged_modules = merge[["colors"]],
  mapping_tbl = adj_matrix_ME$mapping_tbl,
  data = datExpr
)

# saveRDS(
#   module_genes,
#   here::here(
#     glue::glue(
#       "./data/tmp/{which.sample}_module_genes.RDS"
#     )
#   )
# )

# TO DO:
# Save the `dat_module_gene` as a database table in the respective database.

```

::: {.callout-note collapse=true}

# Compare GCN vs. ants

```{r}
genes_across_species <- module_genes |> 
  convert_id(
    from = "mouse",
    to = c("cflo", "drosophila")
  )

genes_across_species |> 
  group_by(gene_name, module_identity) |> 
  reframe(
    dmel = length(
      unique(
        na.omit(drosophila_ID)
      )
    ),
    cflo = length(
      unique(
        na.omit(cflo_ID)
      )
    )
  ) |> 
  arrange(
    module_identity,
    desc(dmel),
    desc(cflo)
  ) |> 
  mutate(
    across(
      c(dmel, cflo),
      ~ case_when(
        .x > 1 ~ "multi",
        .x == 1 ~ "single",
        .x == 0 ~ "x",
        .default = NA
      ) |> 
        factor(
          levels = c("multi", "single", "x")
        )
    )
  ) |> 
  group_by(module_identity, dmel, cflo) |> 
  tally() |> 
  arrange(module_identity, desc(n)) |> 
  ungroup() |> 
  DT::datatable(
    rownames = FALSE
  )
```

:::

# Identify rhythmic modules

```{r}
db_rhy <- load_rhy_genes(
  sample = which.sample
)
###-###-###-###-###-###-###-###-
# Set your p-value of choice
# col_pval = "BH.Q"
col_pval = "default.pvalue"
# col_pval = "raw.pvalue"
###-###-###-###-###-###-###-###-
l_module_genes <- module_genes |> 
  arrange(module_identity) |> 
  group_split(module_identity) |> 
  purrr::map(
    ~ .x |> pull(gene_name)
  ) |> 
  setNames(unique(module_genes[["module_identity"]]))

l_rhy_genes <- db_rhy |> 
  purrr::map(
    ~ .x |> 
      filter(
        if_all(
          c(col_pval),
          ~ .x < 0.05
        )
      ) |> 
      filter(
        ID %in% unlist(l_module_genes)
      ) |> 
      pull(1) |> 
      unique()
  ) |> 
  purrr::compact()
```


## Comparison

> Modules vs. Rhythmic genes

```{r comparison_full, fig.height=6, fig.width=14}
writeLines("#####################################################
How many genes are in each of my geneset of interest?
#####################################################")

## MAKE YOUR LIST OF GENES OF INTEREST ##

# LIST ONE - WGCNA modules
list1 <- l_module_genes
writeLines("List of interesting genes #1
----------------------------
Genes in each of the identified gene-clusters or modules")
sapply(list1, length)

## LIST TWO - rhythmic genes
list2 <- l_rhy_genes
writeLines("List of interesting genes #2
----------------------------
Rhythmic genes identified by different algorithms")
sapply(list2, length)

## CHECK FOR OVERLAP
# define size of genome
size = length(unique(c(unlist(list1), unlist(list2))))
# make a GOM object
gom.1v2 <- GeneOverlap::newGOM(
  list2, 
  list1,
  genome.size = size
)
# png(paste0(path_to_repo, "/results/figures/",
#            "02_pogo_GCN/",
#            sample.name[1],"_gom_1v2.png"),
#     width = 35, height = 15, units = "cm", res = 300)
GeneOverlap::drawHeatmap(
  gom.1v2,
  adj.p = TRUE,
  cutoff=0.05,
  what="odds.ratio",
  # what="Jaccard",
  log.scale = T,
  note.col = "black",
  grid.col = "Oranges"
)
# trash <- dev.off()

 # writeLines("How many genes exactly are overlapping between the pairwise comparisons")
# getMatrix(gom.1v4, name = "intersection") %>% t()

writeLines("Visualizing the significant overlaps between your lists of interesting genes and the identified modules")

```

# Network statistics

From [WGCNA-tutorial](https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/Tutorials/Simulated-07-Membership.pdf)


## Intramodular connectivity

"We begin by calculating the intramodular connectivity for each gene. (In network literature, connectivity is often referred to as ”degree”.) The function intramodularConnectivity computes:

- the whole network connectivity *kTotal*,
- the within (intra)module connectivity *kWithin*, 
- the extra-modular connectivity *kOut*=kTotal-kWithin, and 
- the difference of the intra- and extra-modular connectivities *kDiff* = `kIn - kOut` = `2*kIN-kTotal`

```{r}
# From what I can tell, colorh1 in the tutorial refers to moduleColors
colorh1 <- merge$colors

# Calculate the connectivities of the genes
Alldegrees1 = WGCNA::intramodularConnectivity(
  adjMat = adj_matrix, 
  colors = colorh1
) |> 
  tibble::rownames_to_column("gene_name") |>  
    mutate(
      across(
        matches("^k"),
        ~ round(.x, 2)
      )
    )
```

> Calculate the signed kME and display the first few rows/columns.

```{r}
datKME = WGCNA::signedKME(
  datExpr, 
  merge[["modules"]]$newMEs, 
  outputColumnName = ""
)
# # Display the first few rows of the data frame
# datKME[1:6,1:6]
```


Plotting the mean (± 95% CI) connectivity of genes in different modules

```{r, fig.height=10, fig.width=8}
pd <- position_dodge(0.1)

# which_var <- "kTotal"
which_var <- c("kTotal", "kWithin", "kOut", "kDiff")

Alldegrees1 |>  
  # rownames_to_column("gene_name") %>% 
  left_join(
    module_genes, 
    join_by(gene_name)
  ) |> 
  # PLOT FROM RAW DATA
  mutate(
    module_identity = factor(
      module_identity, 
      levels = paste0(
        "C",
        sort(
          unique(module_genes$module_identity) |> 
            stringr::str_replace("C", "") |> 
            as.integer()
        )
      ) |> rev()
    )
  ) |> 
  summarySE(
    measurevar = which_var, 
    groupvars = "module_identity"
  ) |> 
  mutate(
    type = factor(
      type,
      levels = which_var
    )
  ) |> 
  # Plot
  ggplot(
    aes(
      y = module_identity, 
      x = mean,
      group = interaction(module_identity, type)
    )
  ) +
  geom_vline(xintercept = 0, col = "maroon", alpha = 0.7) +
  labs(
    y = "",
    x = glue::glue(
      "Connectivity"
    ),
    title = ""
  ) +
  ## Add error bar here
  geom_errorbar(
    aes(xmin = mean-ci, xmax = mean+ci),
    width = 0.3, 
    position=pd, 
    lwd = 1.3,
    col="black", 
    alpha = 1
  ) +
  # Add the points on top of the error bars
  geom_point(
    position = pd, 
    size = 3,
    col = "black", 
    fill = "orange",
    show.legend = F, 
    pch = 21,
    alpha = 0.9
  ) +
  facet_wrap(
    ~ type,
    nrow = 2
  ) +
  scale_x_continuous(
    n.breaks = 4
  ) +
  theme_bw(25) +
  # scale_color_manual(values=c("#F20505","#F5D736","#0FBF67")) +
  theme(
    legend.position = "none"
  )
  
```

