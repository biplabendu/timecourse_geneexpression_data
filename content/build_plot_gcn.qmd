---
title: "Build gene co-expression network (GCN) from time-course gene expression data"
editor_options: 
  chunk_output_type: console
---

```{r}
dttm <- Sys.Date()
```

---

> Last updated on `r dttm`.

___

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(warning = F)
knitr::opts_chunk$set(message = F)

## For more inspiration on customizing the html output, refer to the following:
# https://bookdown.org/yihui/rmarkdown/html-document.html#table-of-contents

```


```{r lib_params}
library(dplyr)
library(dbplyr)
library(ggplot2)
for (i in list.files(here::here("R"), full.names = TRUE)) {
  source(i)
}

# SAMPLE NAME
## specify sample name
sample.names <- c(
  # dmel
  "dmel-head",
  # mmus
  "mmus-brain_stem", 
  # panu
  "panu-hypothalamus"
)
# sample.cycles <- c("LD", "DD")

## SPECIFY THE DATASET TO BUILD GCN WITH
which.sample <- sample.names[2]

writeLines(
  glue::glue("Sample: {which.sample}")
)
```


# (INT) Create databases

```{r load_data}
data.db <- load_data(
  sample_names = sample.names
)

cat("Structure of input data:")
data.db[[which.sample]] |> 
  head(5) |> 
  mutate_if(
    is.numeric,
    ~ round(.x, 1)
  ) |> 
  DT::datatable(
    caption = "Column 1: Name of feature (gene), Columns 2-N: Timepoints, Value: Expression / Activity",
    rownames = FALSE
  )

# cat("Here are the tables, in each database.")
# purrr::map(
#   data.db,
#   ~ src_dbi(.x)
# )
```

# ONE-SHOT (make_modules)

```{r}
# data.db[[1]] |> 
#   glimpse() |> 
#   make_modules(
#     min_expression = 1,
#     min_timepoints = 4,
#   ) |> 
#   str(max.level = 1)
```

# STEP-BY-STEP

# (PREP) Log-transform data

```{r}
# Define the function
dat <- log2_transform_data(
  data = data.db[[which.sample]],
  id_column = "gene_name"
)
```

# (SUBSET) Filter data

```{r clean_data}
# Which genes are expressed throughout the day in forager heads?
  # count the number of time points that has â‰¥ 1 FPKM
  # subset the data and only keep the filtered genes
  
dat_sub <- dat |> 
  subset_data(
    min_expression = 10,
    min_timepoints = 8,
    id_column = "gene_name"
  )

writeLines("Dimensions of the data post-filtering step [Rows = #genes, Cols = #samples]")
dim(dat[-1])

```

This is our cleaned, input data file for building the circadian GCN. 

# (WGCNA) Format data

- transpose the dataset: rows = timepoints, cols = genes

```{r format_data, fig.height=6, fig.width=6}

datExpr <- dat_sub %>% 
  transpose_data() 
```

## QC

```{r}
datExpr %>%
  check_sample_quality()

datExpr %>% 
  plot_sample_expression()

```


# Calculate gene-gene similarity

```{r gene_sim_matrix, fig.height=6, fig.width=6}
# Calculate Kendall's tau-b correlation for each gene-gene pair
sim_matrix <- calculate_gene_gene_sim(
  data = datExpr,
  name = which.sample,
  cache = FALSE
)

```

## QC

```{r}
cat("Before power transformation:")
plot_sim_matrix(
  matrix = sim_matrix
)
```


# Create adjacency matrix

## USER INPUT REQUIRED ----
To create the adjacency matrix, we need to first identify the soft-thresholding power (see WGCNA for more info).

```{r soft_thresholding_power, fig.height=6, fig.width=8}
sft <- analyze_network_topology(
  data = datExpr
)
```

> NOTE: The scale-free topology fit index reaches close to 1 (red horizontal line) at a `soft-thresholding-power` of `r sft$powerEstimate`.

Now, we can go ahead and create our adjacency matrix by power-transforming the similarity matrix (see WGCNA for more info).


```{r adjacency_matrix, fig.height=6, fig.width=6}
## Specify the soft-thresholding-power
soft.power = sft$powerEstimate

# Construct adjacency matrix
# TO DO: make function ----
adj_matrix <- WGCNA::adjacency.fromSimilarity(
  sim_matrix,
  power = soft.power,
  type = "signed"
) |> 
  as.matrix()

cat("After power transformation:")
plot_sim_matrix(
  matrix = adj_matrix
)
```

# Identify gene clusters

The following steps are performed as per guidelines from the WGCNA package and several tutorials made available online.

### 2.1 Create topological overalp matrix

```{r adj_to_dissTOM, fig.height=4, fig.width=8}
# Turn adjacency into topological overlap
dissTOM = 1 - WGCNA::TOMsimilarity(adj_matrix)
# Call the hierarchical clustering function
geneTree = perform_hclust(
  data = dissTOM
)

```


### 2.2 Identify clusters

User defined parameters:

- minimum size (number of genes) of modules

> We like large modules, so we set the minimum module size relatively high (50).

```{r identify_clusters}
minModuleSize = 50
# Module identification using dynamic tree cut:
modules <- create_modules(
  tree = geneTree,
  dissTOM = dissTOM,
  data = datExpr,
  min_module_size = minModuleSize
)
```


### 2.3 Merge similar modules

User defined parameters:

- minimum correlation between two modules above which they are merged into one | var-name: MEDissThres

```{r merge_clusters}
merge = create_modules(
  tree = geneTree,
  dissTOM = dissTOM,
  min_module_size = minModuleSize,
  merge_cutoff_similarity = 0.8, # 70 % similarity
  data = datExpr
)
```

### 2.4 Calculate module-module similarity

```{r module_sim_matrix, fig.height=6, fig.width=6}

adj_matrix_ME <- calculate_module_module_sim(
  merged_modules = merge[["modules"]]
)

```

### 2.5 Visualize the network

```{r visualize_network, fig.height=8, fig.width=8}
plot_adj_as_network(
  layout = igraph::layout_as_tree,
  matrix = adj_matrix_ME$ME,
  min_edge = 0.5,
  node_label_size = 2,
  node_size = 45,
  edge_size = 5,
  node_frame_col = "grey20",
  node_fill_col = "grey80",
  vertex.frame.width = 4
)
```


# Save module identity

Obtain a list of genes in each module

```{r module_genes_list}
module_genes <- tidy_modules(
  merged_modules = merge[["colors"]],
  mapping_tbl = adj_matrix_ME$mapping_tbl,
  data = datExpr
)

# saveRDS(
#   module_genes,
#   here::here(
#     glue::glue(
#       "./data/tmp/{which.sample}_module_genes.RDS"
#     )
#   )
# )

# TO DO:
# Save the `dat_module_gene` as a database table in the respective database.

```

::: {.callout-note collapse=true}

# Compare GCN vs. ants

```{r}
genes_across_species <- module_genes |> 
  convert_id(
    from = "mouse",
    to = c("cflo", "drosophila")
  )

genes_across_species |> 
  group_by(gene_name, module_identity) |> 
  reframe(
    dmel = length(
      unique(
        na.omit(drosophila_ID)
      )
    ),
    cflo = length(
      unique(
        na.omit(cflo_ID)
      )
    )
  ) |> 
  arrange(
    module_identity,
    desc(dmel),
    desc(cflo)
  ) |> 
  mutate(
    across(
      c(dmel, cflo),
      ~ case_when(
        .x > 1 ~ "multi",
        .x == 1 ~ "single",
        .x == 0 ~ "x",
        .default = NA
      ) |> 
        factor(
          levels = c("multi", "single", "x")
        )
    )
  ) |> 
  group_by(module_identity, dmel, cflo) |> 
  tally() |> 
  arrange(module_identity, desc(n)) |> 
  ungroup() |> 
  DT::datatable(
    rownames = FALSE
  )
```

:::

# Identify rhythmic modules

```{r}
db_rhy <- load_rhy_genes(
  sample = which.sample
)
###-###-###-###-###-###-###-###-
# Set your p-value of choice
# col_pval = "BH.Q"
col_pval = "default.pvalue"
# col_pval = "raw.pvalue"
###-###-###-###-###-###-###-###-
l_module_genes <- module_genes |> 
  arrange(module_identity) |> 
  group_split(module_identity) |> 
  purrr::map(
    ~ .x |> pull(gene_name)
  ) |> 
  setNames(unique(module_genes[["module_identity"]]))

l_rhy_genes <- db_rhy |> 
  purrr::map(
    ~ .x |> 
      filter(
        if_all(
          c(col_pval),
          ~ .x < 0.05
        )
      ) |> 
      filter(
        ID %in% unlist(l_module_genes)
      ) |> 
      pull(1) |> 
      unique()
  ) |> 
  purrr::compact()
```


## Comparison

> Modules vs. Rhythmic genes

```{r comparison_full, fig.height=6, fig.width=14}
writeLines("#####################################################
How many genes are in each of my geneset of interest?
#####################################################")

## MAKE YOUR LIST OF GENES OF INTEREST ##

# LIST ONE - WGCNA modules
list1 <- l_module_genes
writeLines("List of interesting genes #1
----------------------------
Genes in each of the identified gene-clusters or modules")
sapply(list1, length)

## LIST TWO - rhythmic genes
list2 <- l_rhy_genes
writeLines("List of interesting genes #2
----------------------------
Rhythmic genes identified by different algorithms")
sapply(list2, length)

## CHECK FOR OVERLAP
# define size of genome
size = length(unique(c(unlist(list1), unlist(list2))))
# make a GOM object
gom.1v2 <- GeneOverlap::newGOM(
  list2, 
  list1,
  genome.size = size
)
# png(paste0(path_to_repo, "/results/figures/",
#            "02_pogo_GCN/",
#            sample.name[1],"_gom_1v2.png"),
#     width = 35, height = 15, units = "cm", res = 300)
GeneOverlap::drawHeatmap(
  gom.1v2,
  adj.p = TRUE,
  cutoff=0.05,
  what="odds.ratio",
  # what="Jaccard",
  log.scale = T,
  note.col = "black",
  grid.col = "Oranges"
)
# trash <- dev.off()

 # writeLines("How many genes exactly are overlapping between the pairwise comparisons")
# getMatrix(gom.1v4, name = "intersection") %>% t()

writeLines("Visualizing the significant overlaps between your lists of interesting genes and the identified modules")

```



